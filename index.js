// Generated by CoffeeScript 1.9.3
(function() {
  var _, defIncModule,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  _ = require('lodash');

  defIncModule = {

    /**
    * Defines a new Object or a Class that can inherit properties from other objects/classes in
    * a composable way, i.e you can pick, omit and delegate(methods) from the parent objects.
    * @param {object|function} propsDefiner
    * @param {string} type
    * @return {object|function}
     */
    def: function(propsDefiner, type) {
      var attr, baseObj, definedObj, i, j, key, len, ref;
      if (type == null) {
        type = 'object';
      }
      definedObj = this._setObj(propsDefiner, type);
      ref = this.baseObjs;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        baseObj = ref[i];
        this._filter.set(this.options[i]);
        for (key in baseObj) {
          if (!hasProp.call(baseObj, key)) continue;
          attr = baseObj[key];
          if (!this._filter.skip(key)) {
            if (_.isFunction(attr)) {
              this._addMethod(definedObj, key, attr, baseObj);
            } else {
              this._addAttribute(definedObj, key, attr, baseObj);
            }
          }
        }
        if (baseObj.__static__ != null) {
          this._pushStaticMethods(baseObj);
        }
      }
      this._freezeAndHideAttr(definedObj, '_super');
      return this._makeType(definedObj, type);
    },

    /** @private */
    _setObj: function(propsDefiner, type) {
      var accessors, attr, definedObj, includedTypes, key, reservedKeys, tempObj;
      definedObj = {};
      if (_.isFunction(propsDefiner)) {
        propsDefiner.call(definedObj);
      } else {
        definedObj = propsDefiner;
      }
      includedTypes = definedObj.include;
      accessors = definedObj.accessors;
      this._checkIfValid(definedObj, type);
      if (accessors != null) {
        this._defineAccessors(definedObj, accessors);
      }
      this._filterArgs(includedTypes);
      tempObj = {};
      reservedKeys = ['include', 'prototype', 'accessors'];
      for (key in definedObj) {
        attr = definedObj[key];
        if (!_.contains(reservedKeys, key)) {
          tempObj[key] = attr;
        }
      }
      tempObj._super = {};
      definedObj = tempObj;
      this._definedAttrs = _.mapValues(definedObj, function(val) {
        return true;
      });
      this.staticMethods = {};
      return tempObj;
    },
    _addMethod: function(definedObj, key, attr, baseObj) {
      var fn;
      fn = attr;
      fn = this.useParentContext.hasOwnProperty(key) ? fn.bind(baseObj) : fn;
      if (this._definedAttrs.hasOwnProperty(key)) {
        if (key === 'constructor') {
          return this._setSuperConstructor(definedObj, fn);
        } else {
          return definedObj._super[key] = fn;
        }
      } else {
        return definedObj[key] = definedObj._super[key] = fn;
      }
    },
    _addAttribute: function(definedObj, key, attr, baseObj) {
      if (!this._definedAttrs.hasOwnProperty(key)) {
        return definedObj[key] = _.cloneDeep(attr);
      } else if (_.isArray(attr)) {
        return definedObj[key] = definedObj[key].concat(attr);
      } else if (_.isObject(attr) && key !== '_super') {
        return definedObj[key] = _.merge(definedObj[key], attr);
      }
    },

    /**
    * Checks if the object that is supposed to be a class has a constructor, and
    * that the one that is supposed to be a plainObject does not have one.
    * @private
     */
    _checkIfValid: function(obj, type) {
      var hasConstructor, msg;
      hasConstructor = obj.hasOwnProperty('constructor');
      if (type === 'object' && hasConstructor) {
        msg = 'Constructor is a reserved keyword, to define classes\nwhen using def.Class method, but you are\ndefining an object';
        throw new Error(msg);
      } else if (type === 'class' && !hasConstructor) {
        msg('No constructor defined in the object. To create a class a constructor must be defined as a key');
        throw new Error(msg);
      }
    },

    /** @private */
    _defineAccessors: function(obj, accessorsList) {
      var j, len, propertyName, results;
      results = [];
      for (j = 0, len = accessorsList.length; j < len; j++) {
        propertyName = accessorsList[j];
        results.push(Object.defineProperty(obj, propertyName, obj[propertyName]));
      }
      return results;
    },

    /**
    * @TODO Needs to support multiple constructor calling
    * @private
     */
    _setSuperConstructor: function(target, constructor) {
      return target._super.constructor = function() {
        var superArgs;
        superArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return constructor.apply(superArgs.shift(), superArgs);
      };
    },

    /** @private */
    _filterArgs: function(args) {
      this.baseObjs = [];
      this.options = [];
      this.useParentContext = {};
      return _.each(args, (function(_this) {
        return function(arg) {
          var fn, obj;
          if (!_.isObject(arg)) {
            throw new Error('BakeIn only accepts objects/arrays/fns e.g (fn/{} parent objects/classes or an [] with options)');
          } else if (_this._isOptionArr(arg)) {
            return _this.options.push(_this._makeOptionsObj(arg));
          } else if (_.isFunction(arg)) {
            fn = arg;
            obj = _.merge({}, fn.prototype);
            obj.constructor = fn;
            Object.defineProperty(obj, '__static__', {
              value: _.merge({}, fn),
              enumerable: false
            });
            return _this.baseObjs.push(obj);
          } else {
            return _this.baseObjs.push(arg);
          }
        };
      })(this));
    },

    /** @private */
    _isOptionArr: function(arg) {
      var isStringsArray;
      if (_.isArray(arg)) {
        isStringsArray = _.every(arg, function(item) {
          if (_.isString(item)) {
            return true;
          } else {
            return false;
          }
        });
        if (isStringsArray) {
          return true;
        } else {
          throw new Error('Array contains illegal types: The config [] should only contain strings i.e: (attr names or filter symbols (! or *) )');
        }
      } else {
        return false;
      }
    },

    /** @private */
    _makeOptionsObj: function(attrNames) {
      var filterKey;
      filterKey = attrNames[0];
      switch (filterKey) {
        case '!':
          if (attrNames[1] != null) {
            attrNames.shift();
            attrNames = this._filterParentContextFlag(attrNames, true);
            return {
              'exclude': attrNames
            };
          } else {
            return {
              'excludeAll': true
            };
          }
          break;
        case '*':
          return {
            'includeAll': true
          };
        default:
          attrNames = this._filterParentContextFlag(attrNames);
          return {
            'include': attrNames
          };
      }
    },

    /** @private */
    _filterParentContextFlag: function(attrNames, warningOnMatch) {
      var attrName, j, len, newAttrNames;
      newAttrNames = [];
      for (j = 0, len = attrNames.length; j < len; j++) {
        attrName = attrNames[j];
        if (attrName.charAt(0) === '~') {
          if (warningOnMatch) {
            console.warn('The ~ should only be used when including methods, not excluding them');
          }
          attrName = attrName.replace('~', '');
          newAttrNames.push(attrName);
          this.useParentContext[attrName] = true;
        } else {
          newAttrNames.push(attrName);
        }
      }
      return newAttrNames;
    },

    /**
    @private
     */
    _checkForBalance: function(baseObjs, options) {
      if (options.length > 0 && baseObjs.length !== options.length) {
        throw new Error('Invalid number of conf-options: If you provide a conf obj, you must provide one for each baseObj');
      }
      return true;
    },

    /**
    * Helper obj to let us know if we should skip, based on
    * the filter provided and the current key.
    * @private
     */
    _filter: {
      set: function(conf) {
        if (conf != null) {
          this.mode = _.keys(conf)[0];
          this.attrFilters = conf[this.mode];
          if (_.isString(this.attrFilters)) {
            return this.attrFilters = this.attrFilters.split(',');
          }
        } else {
          this.mode = void 0;
          return this.attrFilters = void 0;
        }
      },
      skip: function(key) {
        var keyIndex;
        switch (this.mode) {
          case 'include':
            if (this.attrFilters.length === 0) {
              return true;
            }
            keyIndex = _.indexOf(this.attrFilters, key);
            if (keyIndex >= 0) {
              _.pullAt(this.attrFilters, keyIndex);
              return false;
            } else {
              return true;
            }
            break;
          case 'exclude':
            if (this.attrFilters.length === 0) {
              return false;
            }
            keyIndex = _.indexOf(this.attrFilters, key);
            if (keyIndex >= 0) {
              _.pullAt(this.attrFilters, keyIndex);
              return true;
            } else {
              return false;
            }
            break;
          case 'includeAll':
            return false;
          case 'excludeAll':
            return true;
          default:
            return false;
        }
      }
    },

    /** @private */
    _pushStaticMethods: function(baseObj) {
      var attr, key, ref, results;
      ref = baseObj.__static__;
      results = [];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        attr = ref[key];
        if (!this._filter.skip(key)) {
          results.push(this.staticMethods[key] = attr);
        } else {
          results.push(void 0);
        }
      }
      return results;
    },

    /** @private */
    _freezeAndHideAttr: function(obj, attributeName) {
      if (obj[attributeName] != null) {
        Object.defineProperty(obj, attributeName, {
          enumerable: false
        });
        return Object.freeze(obj[attributeName]);
      }
    },

    /**
    * Makes a pseudoClass (Constructor) and returns it when type is 'class' or
    * it returns the currently defined object as it is (when type is 'object')
    * @private
     */
    _makeType: function(definedObj, type) {
      if (type === 'class') {
        return this._makeConstructor(definedObj);
      } else {
        return definedObj;
      }
    },

    /** @private */
    _makeConstructor: function(obj) {
      var classFn;
      classFn = obj.constructor;
      _.merge(classFn, this.staticMethods);
      classFn.prototype = obj;
      return classFn;
    }
  };

  module.exports = {
    Object: function(obj) {
      return defIncModule.def.call(defIncModule, obj, 'object');
    },
    Class: function(obj) {
      return defIncModule.def.call(defIncModule, obj, 'class');
    }
  };

}).call(this);

//# sourceMappingURL=index.js.map
