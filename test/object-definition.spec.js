// Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice;

  describe('def.Object method', function() {
    return describe('The defined object', function() {
      describe('When using the "extends" directive', function() {
        it('should have all properties from the passed mixin via prototype', function() {
          var definedObj;
          definedObj = def.Object({
            "extends": mixin1
          });
          return expect(definedObj.__proto__).to.have.all.keys('sum', 'multiply');
        });
        return it('should have all properties from the passed Class prototype without specifying', function() {
          var User, writer;
          User = (function() {
            function User(name1) {
              this.name = name1;
            }

            User.prototype.getName = function() {
              return this.name;
            };

            return User;

          })();
          writer = def.Object({
            "extends": User,
            name: 'Jake',
            write: function() {}
          });
          expect(writer.getName).to.exist;
          expect(writer.getName()).to.equal('Jake');
          return expect(writer.write).to.exist;
        });
      });
      return describe('When using the "merges" directive', function() {
        it('should have all properties from the included (merged) mixins', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, mixin2, mixin6]
          });
          return expect(definedObj).to.have.all.keys('_super', 'increaseByOne', 'sum', 'multiply', 'pow', 'enable', 'itemList');
        });
        it('should be able to call the inherited methods', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, mixin2, mixin6]
          });
          expect(definedObj.sum(5, 10)).to.equal(15);
          expect(definedObj.increaseByOne(3)).to.equal(4);
          expect(definedObj.multiply(4, 2)).to.equal(8);
          return expect(definedObj.pow(2, 3)).to.equal(9);
        });
        describe('the inherited attributes(data)', function() {
          it('should have been cloned and not just referenced', function() {
            var definedObj;
            definedObj = def.Object({
              merges: [mixin5, mixin6]
            });
            delete mixin5.preferences.fullScreen;
            return expect(definedObj.preferences.fullScreen).to.exist;
          });
          return after(function() {
            return mixin5.preferences = {
              fullScreen: true
            };
          });
        });
        describe('When the merged mixins or the currently defined Object/Class has a name conflict on an attribute(data)', function() {
          return it('should merge them with the following precedence: From left to right in the merges mixins list, being the last one the one with more precedence, only surpassed by the attribute defined in the current Object/Class itself', function() {
            var definedObj;
            definedObj = def.Object({
              merges: [mixin5, mixin6],
              increaseByOne: function(n) {
                return this.sum(n, 1);
              },
              preferences: {
                autoPlay: true,
                muted: true
              },
              favoriteChannels: [31, 23]
            });
            expect(definedObj.enable).to.be["false"];
            expect(definedObj.preferences.fullScreen).to.be["true"];
            expect(definedObj.preferences.autoPlay).to.be["true"];
            expect(definedObj.preferences.muted).to.be["true"];
            return expect(definedObj.favoriteChannels).to.eql([31, 23]);
          });
        });
        it('should only include the specified attributes from the merged obj/class, when an attr list [] is provided', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, ['sum'], mixin4, ['publicMethod'], mixin6]
          });
          expect(definedObj.sum).to.exist;
          expect(definedObj.multiply).to.not.exist;
          expect(definedObj._privateAttr).to.not.exist;
          expect(definedObj._privateMethod).to.not.exist;
          expect(definedObj._privateMethod2).to.not.exist;
          return expect(definedObj._privateMethod3).to.not.exist;
        });
        it('should be able to exclude an attribute from merged mixin/Class, when an "!" flag is provided e.g: ["!", "attr1", "attr2"]', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, ['!', 'multiply'], mixin6, ['*']]
          });
          expect(definedObj.sum).to.exist;
          return expect(definedObj.multiply).to.not.exist;
        });
        it('should include all attributes from a merged mixin when an ["*"] (includeAll)  flag is provided', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, ['*'], mixin6, ['*']]
          });
          expect(definedObj.sum).to.exist;
          expect(definedObj.multiply).to.exist;
          return expect(definedObj.increaseByOne).to.exist;
        });
        it('should exclude all attributes from a merged mixin when an ["!"] (excludeAll) flag is provided', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1, ['!'], mixin6, ['*']]
          });
          expect(definedObj.sum).to.not.exist;
          expect(definedObj.multiply).to.not.exist;
          return expect(definedObj.increaseByOne).to.exist;
        });
        describe('When merging multiple objects and not passing merging options to all of them', function() {
          return it('should assume an "*" flag for those that are not explicitly defined', function() {
            var definedObj, definedObj2;
            definedObj = def.Object({
              merges: [mixin1, mixin6, ['increaseByOne']]
            });
            expect(definedObj.increaseByOne(4)).to.equal(5);
            expect(definedObj.multiply).to.exist;
            definedObj2 = def.Object({
              merges: [mixin1, ['sum'], mixin6]
            });
            expect(definedObj2.increaseByOne(4)).to.equal(5);
            return expect(definedObj2.multiply).to.not.exist;
          });
        });
        it('should include attributes from constructor functions/classes prototypes, when constructor is excluded', function() {
          var Parent, definedObj;
          Parent = (function() {
            function Parent() {}

            Parent.prototype.someMethod = function() {
              return 'x';
            };

            return Parent;

          })();
          definedObj = def.Object({
            merges: [Parent, ['!', 'constructor'], mixin6, ['*']]
          });
          expect(definedObj.someMethod).to.exist;
          return expect(definedObj.someMethod()).to.equal('x');
        });
        it('should throw an error when a constructor method is defined', function() {
          var defObject;
          defObject = function() {
            return def.defObject({
              constructor: function() {
                return true;
              }
            });
          };
          return expect(defObject).to["throw"](Error);
        });
        it('should not include static attributes (classAttributes) from constructor functions/classes', function() {
          var Parent, definedObj;
          Parent = (function() {
            function Parent() {}

            Parent.staticMethod = function() {
              return 'y';
            };

            return Parent;

          })();
          definedObj = def.Object({
            merges: [Parent, ['!', 'constructor']]
          });
          return expect(definedObj.staticMethod).to.not.exist;
        });
        describe('When the accessors property is defined', function() {
          describe('In the object passed as argument to the def method (Object/Class)', function() {
            var definedObj;
            definedObj = def.Object({
              accessors: ['fullName'],
              _name: 'John',
              _lastName: 'Doe',
              fullName: {
                get: function() {
                  return this._name + " " + this._lastName;
                },
                set: function(fullName) {
                  var nameParts;
                  nameParts = fullName.split(' ');
                  this._name = nameParts[0];
                  return this._lastName = nameParts[1];
                }
              }
            });
            it('should set the getter to the specified attribute', function() {
              return expect(definedObj.fullName).to.equal('John Doe');
            });
            return it('should set the setter to the specified attribute', function() {
              definedObj.fullName;
              return expect(definedObj.fullName).to.equal('John Doe');
            });
          });
          return describe('In a fn passed as argument to the def method (Object/Class)', function() {
            var definedObj;
            definedObj = def.Object(function() {
              var lastName, name;
              name = 'John';
              lastName = 'Doe';
              this.accessors = ['fullName'];
              return this.fullName = {
                get: function() {
                  return name + " " + lastName;
                },
                set: function(fullName) {
                  var nameParts;
                  nameParts = fullName.split(' ');
                  name = nameParts[0];
                  return lastName = nameParts[1];
                }
              };
            });
            it('should set the getter to the specified attribute', function() {
              return expect(definedObj.fullName).to.equal('John Doe');
            });
            return it('should set the setter to the specified attribute', function() {
              definedObj.fullName;
              return expect(definedObj.fullName).to.equal('John Doe');
            });
          });
        });
        describe('when using a function as argument instead of an obj', function() {
          it('should be able to call truly static private attributes, when defining it as a local variable of the fn', function() {
            var definedObj;
            definedObj = def.Object(function() {
              var privateVar;
              privateVar = 5;
              this.set = function(n) {
                return privateVar = n;
              };
              return this.get = function() {
                return privateVar;
              };
            });
            expect(definedObj.privateVar).to.not.exist;
            expect(definedObj.get()).to.equal(5);
            definedObj.set(4);
            return expect(definedObj.get()).to.equal(4);
          });
          return it('should be able to call truly private methods, when defining it as a local variable of the fn', function() {
            var definedObj;
            definedObj = def.Object(function() {
              var square;
              this.calculate = function(n) {
                return square(n);
              };
              return square = function(n) {
                return n * n;
              };
            });
            return expect(definedObj.calculate(5)).to.equal(25);
          });
        });
        describe('When an attribute(Only methods) is marked with the ~ flag in the filter array, e.g: ["~methodName"]', function() {
          it('should bind the method context to the original obj (parent) instead of the target obj', function() {
            var definedObj;
            definedObj = def.Object({
              merges: [mixin4, ['~publicMethod']]
            });
            expect(definedObj._privateAttr).to.not.exist;
            expect(definedObj._privateMethod).to.not.exist;
            expect(definedObj.publicMethod).to.exist;
            return expect(definedObj.publicMethod(2)).to.equal(10);
          });
          return it('should ignore ~ when using the exclude flag', function() {
            var definedObj;
            definedObj = def.Object({
              merges: [mixin4, ['!', '~_privateMethod']]
            });
            return expect(definedObj._privateMethod).to.not.exist;
          });
        });
        describe('When inheriting from multiple objects', function() {
          return it('should include/inherit attributes in the opposite order they were passed to the function, so the last ones takes precedence over the first ones, when an attribute is found in more than one object', function() {
            var definedObj, definedObj2;
            definedObj = def.Object({
              merges: [
                mixin1, {
                  multiply: function(x) {
                    return x;
                  }
                }
              ]
            });
            expect(definedObj.multiply(5)).to.equal(5);
            definedObj2 = def.Object({
              merges: [definedObj, mixin1]
            });
            return expect(definedObj2.multiply(5, 5)).to.equal(25);
          });
        });
        describe('When overriding a method in the defined object', function() {
          var definedObj;
          definedObj = def.Object({
            merges: [mixin1],
            multiply: function() {
              var numbers;
              numbers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              return this._super.multiply.apply(this, numbers) * 2;
            }
          });
          describe('The _super object', function() {
            describe('When the defined object merges in an object literal (vanilla js)', function() {
              return it('should have all methods from the parent, overridden or not', function() {
                return expect(Object.keys(definedObj._super)).to.eql(['sum', 'multiply']);
              });
            });
            return describe('When the defined object merges in an object defined via def-type module', function() {
              var definedMixin, definedObj2;
              definedMixin = def.Object({
                sum: function() {
                  var i, len, n, numbers, r;
                  numbers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  r = 0;
                  for (i = 0, len = numbers.length; i < len; i++) {
                    n = numbers[i];
                    r += n;
                  }
                  return r;
                }
              });
              definedObj2 = def.Object({
                merges: [definedMixin],
                multiply: function() {
                  var numbers;
                  numbers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                  return definedObj2._super.multiply.apply(this, numbers) * 2;
                }
              });
              return it('should have all methods from the parent, overridden or not', function() {
                return expect(Object.keys(definedObj2._super)).to.eql(['sum']);
              });
            });
          });
          return it('should be able to call the parent obj method via the _super obj', function() {
            return expect(definedObj.multiply(2, 2)).to.equal(8);
          });
        });
        return describe('When a property is defined with a leading underscore in the passed argument object/fn', function() {
          it('should have that property marked as nonEnumerable', function() {
            var definedObj;
            def.setNonEnum('_', true);
            definedObj = def.Object({
              calculation: function(x) {
                return this._pseudoPrivateSquare(x);
              },
              _pseudoPrivateSquare: function(x) {
                return x * x;
              }
            });
            return expect(Object.keys(definedObj)).to.eql(['calculation']);
          });
          it('should not have that property marked as nonEnumerable if the "nonEnumOnPrivate" setting is turned off globally', function() {
            var definedObj;
            def.setNonEnum('_', false);
            definedObj = def.Object({
              calculation: function(x) {
                return this._pseudoPrivateSquare(x);
              },
              _pseudoPrivateSquare: function(x) {
                return x * x;
              }
            });
            expect(Object.keys(definedObj)).to.eql(['calculation', '_pseudoPrivateSquare', '_super']);
            return def.setNonEnum('_', true);
          });
          return it('should not have that property marked as nonEnumerable if the "nonEnumOnPrivate" setting is turned off locally', function() {
            var definedObj;
            definedObj = def.Object({
              nonEnum: ['_', false],
              calculation: function(x) {
                return this._pseudoPrivateSquare(x);
              },
              _pseudoPrivateSquare: function(x) {
                return x * x;
              }
            });
            return expect(Object.keys(definedObj)).to.eql(['calculation', '_pseudoPrivateSquare', '_super']);
          });
        });
      });
    });
  });

}).call(this);

//# sourceMappingURL=object-definition.spec.js.map
